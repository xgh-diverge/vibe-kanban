use std::{env, fs, path::Path};

use remote::{
    db::{
        issue_assignees::IssueAssignee,
        issue_comment_reactions::IssueCommentReaction,
        issue_comments::IssueComment,
        issue_dependencies::IssueDependency,
        issue_followers::IssueFollower,
        issue_tags::IssueTag,
        issues::Issue,
        notifications::{Notification, NotificationType},
        project_statuses::ProjectStatus,
        projects::Project,
        tags::Tag,
        types::{IssuePriority, WorkspacePrStatus},
        users::UserData,
        workspaces::Workspace,
    },
    shapes::all_shapes,
};
use ts_rs::TS;

fn main() {
    let args: Vec<String> = env::args().collect();
    let check_mode = args.iter().any(|arg| arg == "--check");

    let typescript = export_shapes();

    // Path to shared/remote-types.ts relative to workspace root
    let output_path = Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent() // crates/
        .unwrap()
        .parent() // workspace root
        .unwrap()
        .join("shared/remote-types.ts");

    if check_mode {
        let current = fs::read_to_string(&output_path).unwrap_or_default();
        if current == typescript {
            println!("✅ shared/remote-types.ts is up to date.");
            std::process::exit(0);
        } else {
            eprintln!("❌ shared/remote-types.ts is not up to date.");
            eprintln!("Please run 'pnpm run remote:generate-types' and commit the changes.");
            std::process::exit(1);
        }
    } else {
        fs::write(&output_path, &typescript).expect("Failed to write remote-types.ts");
        println!(
            "✅ Generated remote types and shapes to {}",
            output_path.display()
        );
    }
}

/// Generate TypeScript shapes file with embedded types and shape definitions
fn export_shapes() -> String {
    let shapes = all_shapes();

    let mut output = String::new();

    // Header
    output.push_str("// This file was auto-generated by generate_types in the remote crate.\n");
    output.push_str("// Do not edit manually.\n\n");

    // Generate type declarations for all Electric types
    output.push_str("// Electric row types\n");
    let type_decls = vec![
        serde_json::Value::decl(),
        Project::decl(),
        Notification::decl(),
        NotificationType::decl(),
        Workspace::decl(),
        ProjectStatus::decl(),
        Tag::decl(),
        Issue::decl(),
        IssueAssignee::decl(),
        IssueFollower::decl(),
        IssueTag::decl(),
        IssueDependency::decl(),
        IssueComment::decl(),
        IssueCommentReaction::decl(),
        IssuePriority::decl(),
        WorkspacePrStatus::decl(),
        UserData::decl(),
    ];

    for decl in type_decls {
        let trimmed = decl.trim_start();
        if trimmed.starts_with("export") {
            output.push_str(&decl);
        } else {
            output.push_str("export ");
            output.push_str(trimmed);
        }
        output.push_str("\n\n");
    }

    // ShapeDefinition interface
    output.push_str("// Shape definition interface\n");
    output.push_str("export interface ShapeDefinition<T> {\n");
    output.push_str("  readonly table: string;\n");
    output.push_str("  readonly params: readonly string[];\n");
    output.push_str("  readonly url: string;\n");
    output.push_str("  readonly _type: T;  // Phantom field for type inference\n");
    output.push_str("}\n\n");

    // Helper function
    output.push_str("// Helper to create type-safe shape definitions\n");
    output.push_str("function defineShape<T>(\n");
    output.push_str("  table: string,\n");
    output.push_str("  params: readonly string[],\n");
    output.push_str("  url: string\n");
    output.push_str("): ShapeDefinition<T> {\n");
    output.push_str("  return { table, params, url, _type: null as unknown as T };\n");
    output.push_str("}\n\n");

    // Generate individual shape definitions
    output.push_str("// Individual shape definitions with embedded types\n");
    for shape in &shapes {
        let const_name = shape.table().to_uppercase();
        let params_str = shape
            .params()
            .iter()
            .map(|p| format!("'{}'", p))
            .collect::<Vec<_>>()
            .join(", ");

        output.push_str(&format!(
            "export const {}_SHAPE = defineShape<{}>(\n  '{}',\n  [{}] as const,\n  '{}'\n);\n\n",
            const_name,
            shape.ts_type_name(),
            shape.table(),
            params_str,
            shape.url()
        ));
    }

    // Generate ALL_SHAPES array
    output.push_str("// All shapes as an array for iteration and factory building\n");
    output.push_str("export const ALL_SHAPES = [\n");
    for shape in &shapes {
        let const_name = shape.table().to_uppercase();
        output.push_str(&format!("  {}_SHAPE,\n", const_name));
    }
    output.push_str("] as const;\n\n");

    // Type helpers
    output.push_str("// Type helper to extract row type from a shape\n");
    output
        .push_str("export type ShapeRowType<S extends ShapeDefinition<unknown>> = S['_type'];\n\n");
    output.push_str("// Union of all shape types\n");
    output.push_str("export type AnyShape = typeof ALL_SHAPES[number];\n");

    output
}
